<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <style type="text/css">
        * {
            margin: 10px;
            padding: 0;
        }

        canvas {
            display: inline-block;
            border: 1px solid #999;
            border-radius: 5px;
        }

        canvas.error {
            background: rgba(255, 0, 0, 0.25);
        }

        ::selection {
            background: transparent;
        }

        #turtle-canvas {
            position: absolute;
            left: 20px;
            top: 59px;
        }
    </style>
</head>
<body>
    Veiksmas:
    <select id="action">
        <option value="">Jokio</option>
        <option value="Fwd">Pirmyn</option>
        <option value="Bk">Atgal</option>
        <option value="Turn">Pasisukti</option>
        <option value="Rnd">Pasisukti atsitiktinai</option>
    </select>
    Rodyklė:
    <select id="conditioning">
        <option value="">Besąlygiška</option>
        <option value="Obstacle">Tik priešais kliūtį</option>
        <option value="Portal">Tik priešais portalą</option>
        <option value="Path">Tik priešais kelią</option>
    </select>
    Lėtinimas, ms:
    <input type="number" id="speed" value="1000">
    <br>
    <canvas id="turtle-canvas" height="200" width="200"></canvas>
    <canvas id="canvas" height="450" width="1000"></canvas>
    <script type="text/javascript">
        var canvas = document.getElementById('canvas');
        var turtleCanvas = document.getElementById('turtle-canvas');
        var ctx = canvas.getContext('2d');
        var bubbles = [];
        var dragging = false;
        var source = null;
        var target = null;
        var lines = [];
        var label = '';
        var movement = 0;
        var time;
        var turtles = [{x: 4, y: 2, direction: 2, moved: true}];
        var directions = [
            {x: 1, y: 0},
            {x: 0, y: 1},
            {x: -1, y: 0},
            {x: 0, y: -1}
        ];
        var env = [
            '##########',
            '#...#...P#',
            '#...#....#',
            '#...#....#',
            '#...#....#',
            '#...###..#',
            '#.....#..#',
            '#.#####..#',
            '#........#',
            '##########'
        ];
        var grid = [];
        var speed = 1000;

        var admits = function(condition) {
            var x = turtles[0].x + directions[turtles[0].direction].x;
            var y = turtles[0].y + directions[turtles[0].direction].y;
            var result =
                (condition == '') ||
                (condition == 'Path' && grid[x][y] == '.') ||
                (condition == 'Portal' && grid[x][y] == 'P') ||
                (condition == 'Obstacle' && grid[x][y] == '#');
            return result;
        };

        var commands = function(all) {
            if (all.length == 0) {
                return;
            }
            var newTurtles = [];
            for (k in all) {
                var c = all[k];
                if (c == 'Fwd') {
                    for (j in turtles) {
                        var turtle = turtles[j];
                        var d = directions[turtle.direction];
                        newTurtles.push({x: turtle.x + d.x, y: turtle.y + d.y, direction: turtle.direction, moved: true});
                    }
                }
                if (c == 'Bk') {
                    for (j in turtles) {
                        var turtle = turtles[j];
                        var d = directions[turtle.direction];
                        newTurtles.push({x: turtle.x - d.x, y: turtle.y - d.y, direction: turtle.direction, moved: true});
                    }
                }
                if (c == 'Turn') {
                    for (j in turtles) {
                        var turtle = turtles[j];
                        newTurtles.push({x: turtle.x, y: turtle.y, direction: (turtle.direction + 1) % 4, moved: false});
                    }
                }
                if (c == 'Rnd') {
                    for (j in turtles) {
                        var turtle = turtles[j];
                        newTurtles.push({x: turtle.x, y: turtle.y, direction: (turtle.direction + parseInt(Math.floor(Math.random() * 4))) % 4, moved: false});
                    }
                }
                if (c == '') {
                    for (j in turtles) {
                        var t = turtles[j];
                        newTurtles.push({x: t.x, y: t.y, direction: t.direction, moved: false});
                    }
                }
            }
            turtles = [];
            for (k in newTurtles) {
                var duplicate = false;
                var t = newTurtles[k];
                for (j in newTurtles) {
                    if (j <= k) {
                        continue;
                    }
                    var u = newTurtles[j];
                    if (t.x == u.x && t.y == u.y && t.direction == u.direction && t.moved == u.moved) {
                        duplicate = true;
                        break;
                    }
                }
                if (!duplicate) {
                    turtles.push(newTurtles[k]);
                }
            }
            drawTurtles();
        };

        var drawTurtles = function() {
            /*
            var tctx = turtleCanvas.getContext('2d');
            if (turtles.length > 10000) {
                console.log('too many turtles');
                turtles = [];
            }
            tctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            for (k in turtles) {
                turtle = turtles[k];
                if (turtle.moved) {
                    tctx.fillRect(turtle.x, turtle.y, 10, 10);
                }
            }
            */
            grid = [];
            for (k in env) {
                grid.push([]);
                for (j in env[k]) {
                    grid[k].push(env[k][j]);
                }
            }
            for (k in turtles) {
                var t = turtles[k];
                if (env[t.x][t.y] != '.') {
                    canvas.setAttribute('class', 'error');
                    return;
                }
                grid[t.x][t.y] = 'T';
            }
            drawGrid();
        };

        var drawGrid = function() {
            var tctx = turtleCanvas.getContext('2d');
            tctx.clearRect(0, 0, 200, 200);
            var x = 0, y = 0;
            for (k in grid) {
                x = 0;
                for (j in grid[k]) {
                    switch (grid[k][j]) {
                        case '#':
                            tctx.fillStyle = 'brown';
                            break;
                        case '.':
                            tctx.fillStyle = 'green';
                            break;
                        case 'T':
                            tctx.fillStyle = 'white';
                            break;
                        case 'P':
                            tctx.fillStyle = 'purple';
                            break;
                    }
                    tctx.fillRect(x, y, 20, 20);
                    x += 20;
                }
                y += 20;
            }
        };

        var drawLine = function(source, target, condition) {
            ctx.beginPath();
            var d = {x: bubbles[target].x - bubbles[source].x, y: bubbles[target].y - bubbles[source].y};
            var dl = Math.sqrt(Math.pow(d.x, 2) + Math.pow(d.y, 2));
            d.x /= dl;
            d.y /= dl;
            var colors = {'': 'black', 'Obstacle': 'brown', 'Portal': 'purple', 'Path': 'green'};
            ctx.strokeStyle = colors[condition];
            ctx.moveTo(bubbles[source].x + d.x * bubbles[source].radius, bubbles[source].y + d.y * bubbles[source].radius);
            ctx.lineTo(bubbles[target].x - d.x * (bubbles[target].radius + 15), bubbles[target].y - d.y * (bubbles[target].radius + 15));
            ctx.stroke();
            ctx.beginPath();
            ctx.save();
            ctx.translate(bubbles[target].x - d.x * bubbles[target].radius, bubbles[target].y - d.y * bubbles[target].radius);
            ctx.rotate(Math.atan(d.y / d.x) + ((d.x >= 0) ? 90 : -90) * Math.PI / 180);
            ctx.moveTo(0, 0);
            ctx.lineTo(5, 15);
            ctx.lineTo(-5, 15);
            ctx.closePath();
            ctx.restore();
            ctx.fillStyle = colors[condition];
            ctx.fill();
        };

        var mouseUp = function(event) {
            if (Date.now() - time > 500 && movement < 5) {
                execute(locate(event.pageX - canvas.offsetLeft, event.pageY - canvas.offsetTop));
                return false;
            }
            if (dragging) {
                target = null;
                target = locate(event.pageX - canvas.offsetLeft, event.pageY - canvas.offsetTop);
                if (target !== null && target != source) {
                    drawLine(source, target, document.getElementById('conditioning').value);
                    lines.push([source, target, document.getElementById('conditioning').value]);
                }
            }
            source = null;
            target = null;
            dragging = false;
            return false;
        };

        var mouseMove = function(event) {
            movement++;
            if (dragging) {

            }
        };

        var drawBubbles = function(selection) {
            for (var j in bubbles) {
                ctx.beginPath();
                ctx.ellipse(bubbles[j].x, bubbles[j].y, bubbles[j].radius, bubbles[j].radius, 0, 0, 2 * Math.PI);
                //ctx.rect(bubbles[j].x - 25, bubbles[j].y - 25, 50, 50);
                ctx.fillStyle = bubbles[j].color.replace('?', selection == j ? '0.9' : '0.3');
                ctx.fill();
                ctx.font = '18px "Segoe UI"';
                ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                ctx.textAlign = 'center';
                ctx.fillText(bubbles[j].label, bubbles[j].x, bubbles[j].y + 7);
            }
            for (var j in lines) {
                drawLine(lines[j][0], lines[j][1], lines[j][2]);
            }
        };

        var shouldInhibitSpawning = function(x, y) {
            for (var k in bubbles) {
                if (Math.pow(bubbles[k].x - x, 2) + Math.pow(bubbles[k].y - y, 2) <= Math.pow(bubbles[k].radius + 25, 2)) {
                    return true;
                }
            }
            return false;
        };

        var locate = function(x, y) {
            for (var k in bubbles) {
                if (Math.pow(bubbles[k].x - x, 2) + Math.pow(bubbles[k].y - y, 2) <= Math.pow(bubbles[k].radius, 2)) {
                    return k;
                }
            }
            return null;
        };

        var clear = function() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        };

        var mouseDown = function(event) {
            clear();
            movement = 0;
            time = Date.now();
            var x = event.pageX - canvas.offsetLeft;
            var y = event.pageY - canvas.offsetTop;
            var selection = locate(x, y);
            if (selection === null) {
                if (!shouldInhibitSpawning(x, y)) {
                    var color = 'rgba(' + Math.floor(Math.random() * 255) + ',' +
                             Math.floor(Math.random() * 255) + ',' + Math.floor(Math.random() * 255) + ', ?)';
                    bubbles.push({x: event.pageX - canvas.offsetLeft, y: event.pageY - canvas.offsetTop, radius: 25, color: color, label: label});
                    selection = bubbles.length - 1;
                }
            }
            drawBubbles(selection);
            dragging = true;
            source = selection;
            return false;
        };

        canvas.addEventListener('mousedown', mouseDown);
        canvas.addEventListener('touchstart', mouseDown);

        canvas.addEventListener('mouseup', mouseUp);
        canvas.addEventListener('touchend', mouseUp);

        canvas.addEventListener('mousemove', mouseMove);
        canvas.addEventListener('touchmove', mouseMove);

        var growing;
        var shrinking;

        var beginPulsation = function(ids) {
            for (k in ids) {
                endPulsation(ids[k]);
            }
            if (ids.length == 0) {
                return;
            }
            var grow = function() {
                for (k in ids) {
                    var id = ids[k];
                    bubbles[id].radius += 1;
                    if (bubbles[id].radius > 35) {
                        window.clearInterval(growing);
                        shrinking = window.setInterval(shrink, 20);
                        break;
                    }
                }
                clear();
                drawBubbles();
            };
            var shrink = function() {
                for (k in ids) {
                    var id = ids[k];
                    bubbles[id].radius -= 1;
                    if (bubbles[id].radius < 25) {
                        window.clearInterval(shrinking);
                        growing = window.setInterval(grow, 20);
                        break;
                    }
                }
                clear();
                drawBubbles();
            };
            growing = window.setInterval(grow, 10);
        };

        var endPulsation = function() {
            for (var k in bubbles) {
                bubbles[k].radius = 25;
            }
            window.clearInterval(growing);
            window.clearInterval(shrinking);
        };

        var currentStates = [];

        var execution;

        var execute = function(id) {
            window.clearInterval(execution);
            currentStates = [id];
            var doExecution = function() {
                endPulsation();
                if (currentStates.length == 0) {
                    clear();
                    drawBubbles();
                    window.clearInterval(execution);
                    return;
                }
                var futureStates = [];
                beginPulsation(currentStates);
                var cmds = [];
                for (k in currentStates) {
                    cmds.push(bubbles[currentStates[k]].label);
                    for (j in lines) {
                        if (lines[j][0] === currentStates[k] && admits(lines[j][2])) {
                            futureStates.push(lines[j][1]);
                        }
                    }
                }
                commands(cmds);
                futureStates = [...new Set(futureStates)];
                currentStates = futureStates;
            };
            doExecution();
            execution = window.setInterval(doExecution, speed);
        };

        canvas.addEventListener('dblclick', function(event) {
            execute(locate(event.pageX - canvas.offsetLeft, event.pageY - canvas.offsetTop));
            return false;
        });

        var action = document.getElementById('action');

        action.addEventListener('change', function() {
            label = action.value;
        });

        var speedSwitch = document.getElementById('speed');

        speedSwitch.addEventListener('blur', function() {
            speed = parseInt(speedSwitch.value);
        });

        drawTurtles();
    </script>
</body>
</html>
